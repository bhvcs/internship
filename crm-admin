1. 디자이너가 그려준 화면을 보고 필요한 api가 뭐가 있을지 구상한다.
상담 예약, 대기, 확정 목록 조회.
상담 승인, 변경, 취소 api.


개요
고객이 상담을 신청할 날짜를 선택해야 됨. 이때 가능한 날짜와 시간만 활성화 해야 됨.
즉, 해당 시간대에 상담 예약을 받을 수 있는지 판단해야 하고, 이에 대한 api 개발이 필요.
이를 위해 모든 상담예약 정보에 대한 테이블과 투권인(투자권유인)들의 스케줄에 대한 테이블을 참조해야 함.
동작부터 알고리즘 설계를 한다.

동작 가정
날짜를 눌렀을 때, 가능한 시간대가 보이겠지. 이를 한 트랜잭션으로 묶어서 api로 만들겠다. 즉, 날짜를 누를 때마다, 각 시간에 대한 가능 여부를 던져주겠다는 것이다.

구현
총 투권인 수를 먼저 구해서 예약을 받을 수 있는 횟수를 구함. 그리고 HashSet을 두어 다음과 같이 관리할 것이다. key: 상담을 받을 수 있는 모든 시간대 | value: 예약을 받을 수 있는 잔여 횟수 .
먼저 투권인들에 대해서 휴가와 같이, 상담 외의 스케줄로 인해 불가능 한 시간대의 value를 줄여야 한다.
지금 생각나는 방법은 두 가지 있다.
첫번 째 방법.
각 시간대 별로 각 투권인들의 스케줄을 보면서 상담이 가능한지 확인하는 함수를 두는 것이다. 시간대는 21개 투권인들은 3명, 63번의 확인이 필요하다. 매번 db를 조회하기엔 낭비가 있을 것 같으니,
투권인들마다 불가능한 시간대를 체크하겠다. 

두번째 방법.
개인 스케줄을 통해서 타겟 날짜와 상관 있는 row들만 들고온다. 투권인들 근무 시간 중 가장 이른 시간을 최소, 늦은 시간을 최대 시간이라고 한다면,
최소 시간과 최대 시간 사이의 구간에 일부라도 겹치는 스케줄들을 들고와야 한다는 뜻이다.
그럼 각 스케줄들을 돌면서 겹치는 구간의 숫자를 하나씩 감소하면 된다.

그럼 일단 타겟 날짜에 가능한 사람들만 남겠다. 시간대는 아직 필터링이 필요함.
스케줄이 잡혀있는 시간이 들쑥날쑥 할 수 있기 때문에 특정 필드로 행을 정렬할 필요는 없어보인다.
각 row를 돌면서 불가능한 시간대에 -- . 
그럼 이제 상담 스케줄을 확인하며 거를 것이다. 그 시간대에 상담이 잡혀있다면 종료 전까지는 추가적인 상담은 잡지 못한다.
상담 시작 시간을 기준으로 group by.
상담 종료 시간을 확인하면서 상담 불가능한 시간대에 --. 상담이 연속적으로 잡히는 경우를 허용할 것이냐. 는 일단 가능하다고 생각.
하루에 상담을 최대 투권인 * 시간대만큼만 받을 수 있으니 해당 row들을 그대로 들고와도 문제 없음.

이렇게 체크가 완료되었으면
HashSet을 돌면서 
- 유선 상담일 경우) 가능한 시간대 모두 return
- 무선 상담일 경우) 1시간인 것을 고려해서, 바로 뒤의 시간대도 가능한지 체크.

---
상담 가능 시간이 투권인들마다 다를 수 있다는 얘기가 나왔다.
그래서 상담사의 근무시간을 필드에 추가할 것이고, 특정 시간대 가능한 상담의 총 횟수를 세는 방식이 달라질 것이다.
근무 시간을 체크 => 상담을 신청할 수 있는 가장 이른 시간대와 늦은 시간대를 설정. 그 시간들을 30분씩 쪼개 => 투권인들의 근무 시간대에 따라 총 횟수를 각각 설정

선택한 날짜와 관련있는 스케쥴 리스트들을 받아왔다.
dictionary를 돌면서 매 스케줄들을 체크할까
혹은 스케쥴을 돌면서 dictionary를 체크할까 ->

상담 가능 최소 시간과 최대 시간은 변수에 저장되어 있다. 
1. scheduleStartDtm에 최소 시간과 스케줄 시작 시간을 비교해서 큰 걸 저장. scheduleEndDtm에는 반대로 저장.
2. 그 구간동안의 시간들은 불가능으로 체크

Q. 오늘 예약같은 경우에는 현 시간 이후의 몇 시간부터 체크할 수 있어야 하는지 정해야 됨.

--
이제는 상담 가능한 날짜도 보여줘야 한다. 이미 targetDate를 넣으면 그 날 상담 가능한 시간들이 나오는 함수를 짰으니, 이를 내부적으로 활용할 수 있을 것이다.
오늘 날짜로부터 30일의 기간동안만 예약이 가능하게 하자. 
시작 날짜와 끝 날짜를 정했고,
휴일에는 따로 표시가 들어가야 하기 때문에 이를 위한 표시도 하고,
나머지 날짜들을 돌면서 예약 가능한 시간이 있는지 확인.

--
지금 하는 것은 가능한 날짜들을 모두 리스트업 하고 있었다.
사수님의 요구 사항은 달력에서 월을 선택하면 그 월 안의 가능한 날짜들을 리턴하는 것이다.
달력을 넘기면 그 달의 1일이 targetDate로 하자.

오늘 날짜와 같은 달을 선택하면)
오늘부터 그 달의 마지막 날까지 ( 예약 가능 최대 날짜가 최소한 31일까지는 잡아둔다는 가정이다 )

오늘보다 전이면 당연히 없음

오늘보다 뒤의 달을 골랐으면

예약 가능 최대 날짜보다 뒤의 달이라면 아무것도 없음
그게 아니라면 그 달의 1일부터 시작해서, min(예약 가능 최대 날짜, 그 달의 끝)
1일부터 그 달의 끝까지. 근데 예약 가능 최대 날짜가 그 달의 끝보다 이른 날짜라면 1일부터 ~ 그달의 끝까지

target-date를 넣었을 때 available한지 판단하는 코드가 있다.
위에서 가능성 있는 날짜들을 골랐으면 그 날짜들 안에서 이 코드를 호출해 실제로 가능한 날짜이면 return 해줄 것.

---

테스트에도 세 종류가 있음.
1. unit test
2. 통합 테스트
3. 기능 테스트

unit test는 도메인 모델과 비즈니스 로직을 테스트, 작은 단위
각 api마다 구현한 서비스 로직이 있는데, 이를 테스트 하는게 아닐까?
통합, 기능 테스트는 주로 두 개 이상의 앱 구성 요소를 사용한다 => 프로덕션에서 사용하는 인프라가 갖춰져야 하고 시간이 오래 걸림.
단위 테스트로 할 수 있으면 단위 테스트로 하자

테스트 프레임워크로는 xUnit을 사용하겠다. 
위에 소개한 테스트의 유형별로 구분할 수도 있고, 프로젝트나 네임스페이스로 구분할 수도 있다.
사내 기존 코드는 프로젝트 별로 구분했기 때문에 이를 따라간다.

기존 코드 분석:
원래는 데이터베이스로부터 받은 정보를 가지고 엔티티 내부를 채운다. 유닛 테스트에서는 데이터베이스와 연결하지 않으므로 직접 모델을 생성한다.
모델 클래스 안에 test용으로 모델 객체를 반환하는 함수가 존재.

Mock 이라는게 있다. 한국어로 모조품이라는 뜻.
테스트할 때 이것으로 데이터베이스인 척하면 됨. 예를 들면, Mock 객체에, 어떤 함수가 호출되면 내가 준비해놓은 리스트를 반환하도록 세팅할 수 있다.

IClassFixture<T> 라는게 있다. 컨트롤러 테스트에서 이를 상속받는다.
해당 인터페이스를 상속 받으면 T 클래스에 해당하는 인스턴스를 생성자에 주입시켜준다. 이를 이용해서
테스트 할 클래스들에서 공통적으로 사용할 환경을 설정하는 것이다.
예를 들여, 컨트롤러 테스트에서 사용할 HTTP 요청 시뮬레이션을 위한 환경 설정과, Mock을 이용한 의존성 주입 설정 등을 처리할 수 있다.

:::

컨트롤러에는 대단한 로직이 없다. 그냥 서비스 객체의 로직만 호출하고 권한에 따라 뱉는 역할일 뿐.
그나마 해볼만 한 것은, 권한에 따라 행동하는지 확인하는 것 뿐.

서비스 계층에서 웬만한 로직이 다 들어가 있다. 그래서 테스트 코드를 돌린다면 서비스 코드를 해봐야 할 것. 또, 모두 데이터베이스와 연결이 필요한 로직.
=> Mock data가 필요하다.

1번째 계획: ContextProvider를 설정.
ContextProvider 에서 ReadOnlyContext와 그냥 Context를 관리하기 때문.
ContextProvider를 만들어주려다보니, 내부 설정이 꽤나 까다로울 수도 있을 것 같았다.

그냥 context로 해도 되지 않을까? 어차피 데이터베이스에 데이터를 접근하려고 만드는 것이고, 인메모리 형식에 가짜 데이터를 넣을거잖아.
: contextProvider 에서 잘못 될 수도 있으니 일단 최대한 contextProvider를 만들어보는 것으로 해보자.
려고 했으나 일단 시작해보는게 중요하기 때문에 adminDbContextProvider는 있는 것을 쓰자. => 말이 되나? 애초에 의존성을 해결하기 어려워서 context만 쓰려했던건데,
service는 adminDbProvider를 의존하고, context만 있더라도 이를 충족시켜줄 수가 없음. 다시 처음으로 돌아가서 contextProvider를 만들자.






