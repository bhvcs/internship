1. 디자이너가 그려준 화면을 보고 필요한 api가 뭐가 있을지 구상한다.
상담 예약, 대기, 확정 목록 조회.
상담 승인, 변경, 취소 api.


개요
고객이 상담을 신청할 날짜를 선택해야 됨. 이때 가능한 날짜와 시간만 활성화 해야 됨.
즉, 해당 시간대에 상담 예약을 받을 수 있는지 판단해야 하고, 이에 대한 api 개발이 필요.
이를 위해 모든 상담예약 정보에 대한 테이블과 투권인(투자권유인)들의 스케줄에 대한 테이블을 참조해야 함.
동작부터 알고리즘 설계를 한다.

동작 가정
날짜를 눌렀을 때, 가능한 시간대가 보이겠지. 이를 한 트랜잭션으로 묶어서 api로 만들겠다. 즉, 날짜를 누를 때마다, 각 시간에 대한 가능 여부를 던져주겠다는 것이다.

구현
총 투권인 수를 먼저 구해서 예약을 받을 수 있는 횟수를 구함. 그리고 HashSet을 두어 다음과 같이 관리할 것이다. key: 상담을 받을 수 있는 모든 시간대 | value: 예약을 받을 수 있는 잔여 횟수 .
먼저 투권인들에 대해서 휴가와 같이, 상담 외의 스케줄로 인해 불가능 한 시간대의 value를 줄여야 한다.
지금 생각나는 방법은 두 가지 있다.
첫번 째 방법.
각 시간대 별로 각 투권인들의 스케줄을 보면서 상담이 가능한지 확인하는 함수를 두는 것이다. 시간대는 21개 투권인들은 3명, 63번의 확인이 필요하다. 매번 db를 조회하기엔 낭비가 있을 것 같으니,
투권인들마다 불가능한 시간대를 체크하겠다. 

두번째 방법.
개인 스케줄을 통해서 타겟 날짜와 상관 있는 row들만 들고온다. 투권인들 근무 시간 중 가장 이른 시간을 최소, 늦은 시간을 최대 시간이라고 한다면,
최소 시간과 최대 시간 사이의 구간에 일부라도 겹치는 스케줄들을 들고와야 한다는 뜻이다.
그럼 각 스케줄들을 돌면서 겹치는 구간의 숫자를 하나씩 감소하면 된다.

그럼 일단 타겟 날짜에 가능한 사람들만 남겠다. 시간대는 아직 필터링이 필요함.
스케줄이 잡혀있는 시간이 들쑥날쑥 할 수 있기 때문에 특정 필드로 행을 정렬할 필요는 없어보인다.
각 row를 돌면서 불가능한 시간대에 -- . 
그럼 이제 상담 스케줄을 확인하며 거를 것이다. 그 시간대에 상담이 잡혀있다면 종료 전까지는 추가적인 상담은 잡지 못한다.
상담 시작 시간을 기준으로 group by.
상담 종료 시간을 확인하면서 상담 불가능한 시간대에 --. 상담이 연속적으로 잡히는 경우를 허용할 것이냐. 는 일단 가능하다고 생각.
하루에 상담을 최대 투권인 * 시간대만큼만 받을 수 있으니 해당 row들을 그대로 들고와도 문제 없음.

이렇게 체크가 완료되었으면
HashSet을 돌면서 
- 유선 상담일 경우) 가능한 시간대 모두 return
- 무선 상담일 경우) 1시간인 것을 고려해서, 바로 뒤의 시간대도 가능한지 체크.

---
상담 가능 시간이 투권인들마다 다를 수 있다는 얘기가 나왔다.
그래서 상담사의 근무시간을 필드에 추가할 것이고, 특정 시간대 가능한 상담의 총 횟수를 세는 방식이 달라질 것이다.
근무 시간을 체크 => 상담을 신청할 수 있는 가장 이른 시간대와 늦은 시간대를 설정. 그 시간들을 30분씩 쪼개 => 투권인들의 근무 시간대에 따라 총 횟수를 각각 설정

선택한 날짜와 관련있는 스케쥴 리스트들을 받아왔다.
dictionary를 돌면서 매 스케줄들을 체크할까
혹은 스케쥴을 돌면서 dictionary를 체크할까 ->

상담 가능 최소 시간과 최대 시간은 변수에 저장되어 있다. 
1. scheduleStartDtm에 최소 시간과 스케줄 시작 시간을 비교해서 큰 걸 저장. scheduleEndDtm에는 반대로 저장.
2. 그 구간동안의 시간들은 불가능으로 체크

Q. 오늘 예약같은 경우에는 현 시간 이후의 몇 시간부터 체크할 수 있어야 하는지 정해야 됨.

--
이제는 상담 가능한 날짜도 보여줘야 한다. 이미 targetDate를 넣으면 그 날 상담 가능한 시간들이 나오는 함수를 짰으니, 이를 내부적으로 활용할 수 있을 것이다.
오늘 날짜로부터 30일의 기간동안만 예약이 가능하게 하자. 
시작 날짜와 끝 날짜를 정했고,
휴일에는 따로 표시가 들어가야 하기 때문에 이를 위한 표시도 하고,
나머지 날짜들을 돌면서 예약 가능한 시간이 있는지 확인.

--
지금 하는 것은 가능한 날짜들을 모두 리스트업 하고 있었다.
사수님의 요구 사항은 달력에서 월을 선택하면 그 월 안의 가능한 날짜들을 리턴하는 것이다.
달력을 넘기면 그 달의 1일이 targetDate로 하자.

오늘 날짜와 같은 달을 선택하면)
오늘부터 그 달의 마지막 날까지 ( 예약 가능 최대 날짜가 최소한 31일까지는 잡아둔다는 가정이다 )

오늘보다 전이면 당연히 없음

오늘보다 뒤의 달을 골랐으면

예약 가능 최대 날짜보다 뒤의 달이라면 아무것도 없음
그게 아니라면 그 달의 1일부터 시작해서, min(예약 가능 최대 날짜, 그 달의 끝)
1일부터 그 달의 끝까지. 근데 예약 가능 최대 날짜가 그 달의 끝보다 이른 날짜라면 1일부터 ~ 그달의 끝까지

target-date를 넣었을 때 available한지 판단하는 코드가 있다.
위에서 가능성 있는 날짜들을 골랐으면 그 날짜들 안에서 이 코드를 호출해 실제로 가능한 날짜이면 return 해줄 것.

스케쥴 관리 로직은 상담사가 상담을 예약할 떄에도 필요하다. 각 상담사는 자기 스케줄과 겹치는 상담에 대해서는 승인을 할 수가 없어야 한다.
1. 상담 시작 시간 ~ 상담 종료 시간을 체크
2. 자신의 스케줄과 겹치는지 확인
3. 없으면 상담 시간 중 자신의 상담 시간과 겹치는지 확인.

각 상담 건당, 스케줄 테이블과 상담 확정 테이블을 조회했다. 한 페이지에, 상담이 여러 개가 올텐데, db에 과도한 요청을 보내게 되는 문제가 발생.

차라리, 한 페이지에 올 상담들 중에, 가장 빠른 시작 시간과, 가장 늦은 종료 시간이 있을 것이다. 해당 범위로 스케줄과 상담 확정 테이블에서 데이터를 한번에 들고와서 처리하자.
이렇게 하면 상담이 한 페이지에 100개를 보여줄 떄, 200번 db에 요청 보내던 것을 두 번으로 줄일 수 있다. 이게 무조건 답인 것은 아니지만, 시간 범위 내의 스케줄과 상담 확정 목록을 들고 오는 것이 훨씬 낫다는
생각이다.

근무시간을 생각 안했음.
1. 근무 시간에 맞게 상담 승인 활성화 비활성화가 필요함
  근무 시간에 안맞는 상담은 나오지 않는지 확인 필요: 
  
2. 스케쥴에 가능한 시간을 올려놓으면 그 시간에는 가능하도록 해
  상담 예약 가능 여부는 기존 근무시간에 가능 시간을 넣어서.

일단 상담 가능 시간 뽑아내는 로직에 아래를 추가
: 내가 고른 날짜와 연관이 있는, 상담 가능하다고 올려놓은 스케쥴을 리스트업.

수정:
db에 Linq를 사용해서 쿼리를 날리고 있었음. Utc 기준의 DateTimeOffset 필드를 Date로 바꿔서 targetDate와 비교하고 있었음. 동일한 날짜를 가진 행만 비교하려고.
근데 이렇게 하면 내부적으로 모든 필드에 대한 변환이 발생하기 때문에 오히려 복잡해짐. 차라리 targetDate의 00시부터 23:50분까지와 비교하는 것으로 수정.

개장일 고려 해야됨
개장일이 아니라면 가능하다고 올려놓은 스케쥴만 생각하면 됨.
개장일이면 스케쥴 + 나머지 기존 로직

예약 대기 목록 보여줄 때도 가능 스케쥴을 고려 해야됨
처음부터 정리하면.
일단 상담사의 근무 시간은 신경 안써도 됨. 되면 누르면 되지.
같은 이유로 개장일도 신경 안써도 됨.
가능 스케줄에 포함되는 시간대라면)
  상담 확정 목록 중에 이미 잡아 놓은 스케쥴이 없다면 => 상담 승인 가능하다
  불가능 스케쥴은 신경 안써도 됨
가능 스케쥴에 포함되지 않다면)
  기존 로직


===============
swagger에서 테스트

대기 목록 조회

1. 시간은 잘 변환됨 => 확인
2. 스케줄에 걸려서 상담 승인 불가도 보임 => 확인
3. 상담사가 특정 시간대에 잡혀있는 상담이 있으면 그 시간대의 다른 상담은 받을 수 없어야 함 => 확인
4. 상담 가능 스케줄을 고려 => 고려해야 되나? 그냥 받으면 되잖아 => 없애도 됨
5. 정렬 => 예약 일시도 default가 내림차순인데, 이건 오름차순으로 바꿈
6. 이름 및 상담 타입 => 확인

확정 목록 => 확인

내역 => 확인

고객정보 조회 => 확인

상담 예약 가능 날짜

1. 개장일이 아닌 날짜들은 잘빠짐
2. 개장일이 아닌데 스케줄 가능으로 올려놓은게 있으면, 가능한 날짜에 포함되어야 함 => 확인

상담 예약 가능 시간 => 개장일, 예약 확정 상담, 가능 스케쥴, 불가능 스케쥴 고려 => 확인



---

테스트에도 세 종류가 있음.
1. unit test
2. 통합 테스트
3. 기능 테스트

unit test는 도메인 모델과 비즈니스 로직을 테스트, 작은 단위
각 api마다 구현한 서비스 로직이 있는데, 이를 테스트 하는게 아닐까?
통합, 기능 테스트는 주로 두 개 이상의 앱 구성 요소를 사용한다 => 프로덕션에서 사용하는 인프라가 갖춰져야 하고 시간이 오래 걸림.
단위 테스트로 할 수 있으면 단위 테스트로 하자

테스트 프레임워크로는 xUnit을 사용하겠다. 
위에 소개한 테스트의 유형별로 구분할 수도 있고, 프로젝트나 네임스페이스로 구분할 수도 있다.
사내 기존 코드는 프로젝트 별로 구분했기 때문에 이를 따라간다.

기존 코드 분석:
원래는 데이터베이스로부터 받은 정보를 가지고 엔티티 내부를 채운다. 유닛 테스트에서는 데이터베이스와 연결하지 않으므로 직접 모델을 생성한다.
모델 클래스 안에 test용으로 모델 객체를 반환하는 함수가 존재.

Mock 이라는게 있다. 한국어로 모조품이라는 뜻.
테스트할 때 이것으로 데이터베이스인 척하면 됨. 예를 들면, Mock 객체에, 어떤 함수가 호출되면 내가 준비해놓은 리스트를 반환하도록 세팅할 수 있다.

IClassFixture<T> 라는게 있다. 컨트롤러 테스트에서 이를 상속받는다.
해당 인터페이스를 상속 받으면 T 클래스에 해당하는 인스턴스를 생성자에 주입시켜준다. 이를 이용해서
테스트 할 클래스들에서 공통적으로 사용할 환경을 설정하는 것이다.
예를 들여, 컨트롤러 테스트에서 사용할 HTTP 요청 시뮬레이션을 위한 환경 설정과, Mock을 이용한 의존성 주입 설정 등을 처리할 수 있다.

:::

컨트롤러에는 대단한 로직이 없다. 그냥 서비스 객체의 로직만 호출하고 권한에 따라 뱉는 역할일 뿐.
그나마 해볼만 한 것은, 권한에 따라 행동하는지 확인하는 것 뿐.

서비스 계층에서 웬만한 로직이 다 들어가 있다. 그래서 테스트 코드를 돌린다면 서비스 코드를 해봐야 할 것. 또, 모두 데이터베이스와 연결이 필요한 로직.
=> Mock data가 필요하다.

테스트 방향성:
경계성 데이터가 들어왔을 때


1번째 계획: ContextProvider를 설정.
ContextProvider 에서 ReadOnlyContext와 그냥 Context를 관리하기 때문.
ContextProvider를 만들어주려다보니, 내부 설정이 꽤나 까다로울 수도 있을 것 같았다.

그냥 context로 해도 되지 않을까? 어차피 데이터베이스에 데이터를 접근하려고 만드는 것이고, 인메모리 형식에 가짜 데이터를 넣을거잖아.
: contextProvider 에서 잘못 될 수도 있으니 일단 최대한 contextProvider를 만들어보는 것으로 해보자.
려고 했으나 일단 시작해보는게 중요하기 때문에 adminDbContextProvider는 있는 것을 쓰자. => 말이 되나? 애초에 의존성을 해결하기 어려워서 context만 쓰려했던건데,
service는 adminDbProvider를 의존하고, context만 있더라도 이를 충족시켜줄 수가 없음. 다시 처음으로 돌아가서 contextProvider를 만들자.

기존에 dbcontextProvider가 어떻게 구성된것인지 분석하자.
기본 동작: 이름 그대로 context만을 뱉는다기 보단, 담당하는 context에서 session을 열어, 그 세션을 제공하는 역할임.
기존에 두가지의 context를 받아서 만들어진 contextProvider를 사용하고 있었다. 그 중 한가지는 내가 맡은 부분에서는 사용하지 않는 context이다. 이 부분은 보지 않아도 됨.

___DbContext:
  의존성: encryptionProvider, (http)contextAccessor, DbContextOptions
  속성값: DbSet<TEntity> :: 여기에 엔티티가 담김. 이렇게 해놓으면 Linq 를 사용해서 데이터베이스 조작 가능
  Http Context에는 요청을 보낸 사용자의 정보와 같은게 담김. 이를 사용해서 데이터베이스를 조회하는데에 사용할 수 있음
  encryptionProvider는 context 내의 엔티티에 대해 개별 설정할 때 사용됨.
  의존성 주입할 때, 어떤 녀석들이 들어가는 지 확인해서 직접 넣어주자.
  
  _logger = loggerFactory.CreateLogger<T>();
  T 클래스와 관련된 행동에 대한 로깅을 설정 => 지금 provider와 관련된 설정이므로 provider의 클래스명이 들어가겠다.

  contextprovider를 보면 읽기전용 세션과, 쓰기 가능한 세션을 열어주는 메서드가 있다. 둘의 차이는 트랜잭션의 유무. 트랜잭션은 작업의 원자성을 보장하기 위해 존재하고 읽기 전용일 때
  이런 트랜잭션의 기능은 필요 없다. 그리고 context 안의 엔티티에 변경 사항이 있으면 이를 저장해주는 SaveChangesAsync의 차이가 있겠다.
  둘의 공통점으로 IServiceProvider에서 CreateScope로 스코프를 열어준다. 원래 DI는 컨테이너에 등록된 서비스를 자동으로 넣어주는데, 이는 런타입에 필요할 때 넣어주는 역할이다.

  db가 스코프 단위로 관리되는 이유. 요청이나 작업 단위 하나당, 하나의 트랜잭션이 열려서 db와 소통하는게 안전하기 때문임. 웹 어플리케이션은 한번에 여러 요청이 들어올 수 있는데 독립적인 행동을 보장하려면
  요청 당 트랜잭션이 열려서 관리되어야 한다.

serviceProvider는 원래 프로젝트에서 startup.cs에서 설정되고 있었고, 여기에는 db 사용에 있어 필요한 설정들을 해놓았다. 그리고 dbcontextPool을 설정했다.
pool을 사용해서 설정하지 않으면, dbcontext가 필요할 때마다 객체가 버려지고 생성되고 하겠지? 이러면 리소스 낭비 => pool에서 관리하는 것으로 변경. 그래서 기본적으로 미리 dbcontext를 만들어 pool에 넣으면
사용할 때 꺼내고, 사용하지 않을 때는 pool에 다시 반납 => 리소스 낭비 줄이기.

테스트 코드에서 IServiceProvider 설정을 해보자. ServiceCollection에 의존성들을 담으니 
---
일단 기존 코드에서는 컨텍스트 풀을 사용했음. 근데 테스트 코드에서는 요청이 많지 않으므로 풀은 사용하지 않을 것임.
그리고 생성자 주입이 아닌 lazy loading이라 몰랐는데 contextProvider 에서도 GetService로 dbContext를 가져와서 쓰고 있었음.
그래서 ::
테스트 내부의 DI 컨테이너를 놓고, 그 안에, 사용할 dbContext와 내부적으로 사용할 ServiceProvider, 그리고 test할 ReservationService 를 등록할 것임.
encryptionProvider는 흠.. 이게 환경변수에서 끌고 오는 것 같은데, 내가 데이터베이스에 실제로 암호화 해서 넣는 것은 비효율적이라고 판단한다. 그러니 Mock으로 설정해보면 되지 않을까 싶다.

  var serviceProvider = new ServiceCollection()
        .AddDbContext<YourDbContext>(options => options.UseInMemoryDatabase("TestDatabase"))
        .AddScoped<IDbContextProvider, DbContextProvider>()
        .AddScoped<ReservationService>()
        .BuildServiceProvider();
이걸 활용해서 해보자.

그리고 테스트에서 사용하자.

In-memory 관련 Nuget 패키지를 설치해주고.


serviceProvider와 logger 참조.


--
In-memory db를 사용한다. 기존 코드에서) 참조하는 db는 같아도 용도에 따라 dbcontext를 readonly와 writable로 나누었다.
인메모리 db도 분명 db의 이름을 같게 하면, 다른 context이더라도 같은 db를 보게끔 되는 것으로 알고 있었다.
하지만 왜인지 dbContext에 데이터들을 넣으면, writeable한 dbcontext에서 데이터를 조회했을 때는 테스트 데이터들이 보이는 반명,
readOnlyDbContext에서는 확인되지 않았다. 

공식문서를 본 결과 https://learn.microsoft.com/ko-kr/ef/core/testing/testing-without-the-database#inmemory-provider (메모리 내 데이터베이스 이름 지정)
메모리 내의 데이터베이스는 컨텍스트의 내부 서비스 공급자 (UseInternalServiceProvider)에 루팅된다고 한다. 근데 이때 다양한 옵션을 사용해서 컨텍스트를 구성하면 새로운 내부 서비스 공급자를 트리거할 수 있대.
그니깐 옵션을 다양하게 사용하게 되면 동일한 내부 서비스 공급자를 사용한다고 해도, 실상은 새 공급자가 만들어질 수도 있다는 거지.
=> UseInMemoryDatabase 의 옵션으로 동일한 이름뿐 아니라 동일한 InMeMoryDatabaseRoot 객체를 넣어주면 동일한 데이터베이스를 참조하도록 해준다. 해당 인스턴스는 인메모리 데이터베이스의 루트 역할을 한다.

내가 dbcontext에 대한 여러 옵션들을 빼고 시도해봤다. 하지만 InMeMoryDatabaseRoot 이 녀석의 설정 없이는 동일한 데이터베이스를 공유하지 못했다. 설명에는 분명히 동일한 내부 서비스 공급자를 사용하고 이름이 같다면
공유된다고 했는데, 이상하다. 나도 모르게 내부 서비스 공급자가 새로 만들어지는 것 같은데.. 일단 동일한 InMeMoryDatabaseRoot 객체를 옵션에 넣고 사용하면 해결된다.


예약 활성화/비활성화 할 떄 스케줄 판단 로직

--

예약 대기 목록 테스트 

1. 쿼리가 잘 됐는지
 - 고객 정보가 잘 join 되었는지
 - 예약 대기만 있는지
 - 정렬 잘 되었는지

 - 고객 정보가 잘 join 되었는지
고객 정보 중 Encrypt attribute가 붙은 속성이 몇 개 있는데, encrypt를 잘못해서인지 계속 null로 나온다.

너무 많이 바꿔서 다시 테스트 해야 됨.
근데 아직 테스트 코드를 못짜서 일일이 눌러봐야 됨. 이래서 test 코드를 짜는 거.
테스트한 사항.
db의 udtm 컬럼이 api 반환될 때, dtm으로 제대로 바뀌었는지 => 확인
이번에 가능한 스케쥴에 대한 고려도 추가됨.
 불가능한 스케줄에 포함된다면 상담 승인이 불가능해야됨 => 확인 됨.
